"""
Asset CRUD endpoints (Asynchronous)
"""
from fastapi import APIRouter, HTTPException, Query, Depends
from uuid import UUID
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from ..schemas.asset_schema import AssetCreate, AssetUpdate, AssetResponse, AssetAssignmentRequest, AssetStatusUpdate
from ..services import asset_service
from ..services import asset_request_service
from ..database.database import get_db
from ..models.models import AssetRequest
from datetime import date

router = APIRouter(
    prefix="/assets",
    tags=["assets"]
)


@router.get("", response_model=List[AssetResponse])
async def get_all_assets(db: AsyncSession = Depends(get_db)):
    """
    Get all assets (Asynchronous).
    """
    try:
        return await asset_service.get_all_assets(db)
    except Exception as e:
        import traceback
        traceback.print_exc()
        from fastapi.responses import JSONResponse
        return JSONResponse(
            status_code=500,
            content={"detail": f"Internal server error: {str(e)}"},
            headers={"Access-Control-Allow-Origin": "http://localhost:3000"}
        )


@router.get("/my-assets", response_model=List[AssetResponse])
async def get_my_assets(user: str, db: AsyncSession = Depends(get_db)):
    """
    Get assets assigned to a specific user (Asynchronous).
    """
    return await asset_service.get_assets_by_assigned_to(db, user)


@router.get("/stats")
async def get_asset_stats(db: AsyncSession = Depends(get_db)):
    """
    Get asset statistics for dashboard (Asynchronous).
    """
    return await asset_service.get_asset_stats(db)


@router.get("/renewals")
async def get_assets_for_renewal(
    days_ahead: int = 90,
    expiry_type: str = None,
    db: AsyncSession = Depends(get_db)
):
    """
    Get assets with upcoming expiry dates for renewal calendar.
    expiry_type can be: warranty, contract, license, or None for all.
    """
    from datetime import date as dt_date, timedelta
    from ..models.models import Asset
    
    today = dt_date.today()
    cutoff_date = today + timedelta(days=days_ahead)
    
    result = await db.execute(select(Asset))
    all_assets = result.scalars().all()
    
    renewals = []
    for asset in all_assets:
        expiry_dates = []
        
        if (not expiry_type or expiry_type == "warranty") and asset.warranty_expiry:
            if today <= asset.warranty_expiry <= cutoff_date:
                expiry_dates.append({"type": "warranty", "date": asset.warranty_expiry.isoformat()})
        
        if (not expiry_type or expiry_type == "contract") and asset.contract_expiry:
            if today <= asset.contract_expiry <= cutoff_date:
                expiry_dates.append({"type": "contract", "date": asset.contract_expiry.isoformat()})
        
        if (not expiry_type or expiry_type == "license") and asset.license_expiry:
            if today <= asset.license_expiry <= cutoff_date:
                expiry_dates.append({"type": "license", "date": asset.license_expiry.isoformat()})
        
        if expiry_dates:
            renewals.append({
                "asset_id": str(asset.id),
                "asset_name": asset.name,
                "asset_type": asset.type,
                "serial_number": asset.serial_number,
                "status": asset.status,
                "cost": asset.cost,
                "expiry_dates": expiry_dates
            })
    
    renewals.sort(key=lambda x: min(e["date"] for e in x["expiry_dates"]))
    return {"total_count": len(renewals), "renewals": renewals}


@router.get("/{asset_id}", response_model=AssetResponse)
async def get_asset(asset_id: UUID, db: AsyncSession = Depends(get_db)):
    """
    Get asset by ID (Asynchronous).
    """
    asset = await asset_service.get_asset_by_id(db, asset_id)
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    return asset


@router.post("", response_model=AssetResponse, status_code=201)
async def create_asset(
    asset: AssetCreate,
    db: AsyncSession = Depends(get_db),
    request_id: Optional[UUID] = Query(None, description="Asset request ID")
):
    """
    Create a new asset (Asynchronous).
    """
    if request_id:
        asset_request = await asset_request_service.get_asset_request_by_id(db, request_id)
        if not asset_request:
            raise HTTPException(status_code=404, detail="Asset request not found")
        if asset_request.status != "IT_APPROVED":
            raise HTTPException(status_code=403, detail="Asset request not IT approved")
    
    return await asset_service.create_asset(db, asset)


@router.patch("/{asset_id}", response_model=AssetResponse)
async def update_asset(asset_id: UUID, asset_update: AssetUpdate, db: AsyncSession = Depends(get_db)):
    """
    Update an asset (Asynchronous).
    """
    updated_asset = await asset_service.update_asset(db, asset_id, asset_update)
    if not updated_asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    return updated_asset


@router.patch("/{asset_id}/assign", response_model=AssetResponse)
async def assign_asset(
    asset_id: UUID,
    assignment: AssetAssignmentRequest,
    db: AsyncSession = Depends(get_db),
    request_id: Optional[UUID] = Query(None, description="Asset request ID")
):
    """
    Assign an asset to a user (Asynchronous).
    """
    if request_id:
        asset_request = await asset_request_service.get_asset_request_by_id(db, request_id)
        if not asset_request:
            raise HTTPException(status_code=404, detail="Asset request not found")
        if asset_request.status != "IT_APPROVED":
            raise HTTPException(status_code=403, detail="Asset request not IT approved")
    else:
        # Try to find request by asset_id
        result = await db.execute(select(AssetRequest).filter(AssetRequest.asset_id == asset_id))
        asset_request_db = result.scalars().first()
        if asset_request_db and asset_request_db.status != "IT_APPROVED":
            raise HTTPException(status_code=403, detail="Asset request not IT approved")
    
    assign_date = assignment.assignment_date or date.today()
    
    assigned_asset = await asset_service.assign_asset(
        db,
        asset_id, 
        assignment.assigned_to, 
        assignment.location or "Office", 
        assign_date
    )
    if not assigned_asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    return assigned_asset


@router.patch("/{asset_id}/status", response_model=AssetResponse)
async def update_asset_status(asset_id: UUID, status_update: AssetStatusUpdate, db: AsyncSession = Depends(get_db)):
    """
    Update asset status (Asynchronous).
    Accepts JSON body with 'status' field.
    """
    updated_asset = await asset_service.update_asset(db, asset_id, AssetUpdate(status=status_update.status))
    if not updated_asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    return updated_asset


@router.get("/{asset_id}/events")
async def get_asset_events(asset_id: UUID, db: AsyncSession = Depends(get_db)):
    """
    Get asset event history (Asynchronous).
    """
    events = await asset_service.get_asset_events(db, asset_id)
    if events is None:
        raise HTTPException(status_code=404, detail="Asset not found")
    return events


@router.delete("/{asset_id}")
async def delete_asset(
    asset_id: UUID,
    hard_delete: bool = False,
    db: AsyncSession = Depends(get_db)
):
    """
    Delete an asset (Asynchronous).
    By default, performs a soft delete by setting status to 'Retired'.
    Set hard_delete=true to permanently remove the asset from the database.
    """
    from ..models.models import Asset, AuditLog
    import uuid as _uuid
    
    # Get the asset
    asset = await asset_service.get_asset_by_id(db, asset_id)
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    # Check if asset is currently assigned
    if asset.assigned_to and asset.status == "In Use":
        raise HTTPException(
            status_code=400,
            detail="Cannot delete an asset that is currently assigned. Unassign it first."
        )
    
    if hard_delete:
        # Hard delete - remove from database
        result = await db.execute(
            select(Asset).filter(Asset.id == asset_id)
        )
        asset_to_delete = result.scalars().first()
        if asset_to_delete:
            await db.delete(asset_to_delete)
            
            # Create audit log
            audit_log = AuditLog(
                id=str(_uuid.uuid4()),
                entity_type="Asset",
                entity_id=str(asset_id),
                action="HARD_DELETED",
                performed_by="system",
                details={"asset_name": asset.name, "serial_number": asset.serial_number}
            )
            db.add(audit_log)
            await db.commit()
            
            return {"status": "success", "message": f"Asset {asset_id} permanently deleted"}
    else:
        # Soft delete - set status to Retired
        updated_asset = await asset_service.update_asset(
            db, 
            asset_id, 
            AssetUpdate(status="Retired", disposal_status="SOFT_DELETED")
        )
        
        # Create audit log
        audit_log = AuditLog(
            id=str(_uuid.uuid4()),
            entity_type="Asset",
            entity_id=str(asset_id),
            action="SOFT_DELETED",
            performed_by="system",
            details={"asset_name": asset.name, "previous_status": asset.status}
        )
        db.add(audit_log)
        await db.commit()
        
        return {"status": "success", "message": f"Asset {asset_id} marked as Retired"}


# ===================== CMDB Relationship Endpoints =====================

@router.get("/{asset_id}/relationships")
async def get_asset_relationships(asset_id: UUID, db: AsyncSession = Depends(get_db)):
    """
    Get all relationships for an asset (both upstream and downstream).
    """
    from ..models.models import Asset, AssetRelationship
    
    # Verify asset exists
    asset = await asset_service.get_asset_by_id(db, asset_id)
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    # Get relationships where this asset is the source (downstream/outgoing)
    downstream_result = await db.execute(
        select(AssetRelationship).filter(AssetRelationship.source_asset_id == asset_id)
    )
    downstream_rels = downstream_result.scalars().all()
    
    # Get relationships where this asset is the target (upstream/incoming)
    upstream_result = await db.execute(
        select(AssetRelationship).filter(AssetRelationship.target_asset_id == asset_id)
    )
    upstream_rels = upstream_result.scalars().all()
    
    # Build response with asset details
    async def enrich_relationship(rel, direction):
        if direction == "downstream":
            related_asset = await asset_service.get_asset_by_id(db, rel.target_asset_id)
        else:
            related_asset = await asset_service.get_asset_by_id(db, rel.source_asset_id)
        
        return {
            "id": str(rel.id),
            "relationship_type": rel.relationship_type,
            "direction": direction,
            "criticality": rel.criticality,
            "description": rel.description,
            "related_asset": {
                "id": str(related_asset.id) if related_asset else None,
                "name": related_asset.name if related_asset else "Unknown",
                "type": related_asset.type if related_asset else None,
                "status": related_asset.status if related_asset else None,
            } if related_asset else None,
            "created_at": rel.created_at.isoformat() if rel.created_at else None
        }
    
    upstream = []
    for rel in upstream_rels:
        upstream.append(await enrich_relationship(rel, "upstream"))
    
    downstream = []
    for rel in downstream_rels:
        downstream.append(await enrich_relationship(rel, "downstream"))
    
    return {
        "asset_id": str(asset_id),
        "asset_name": asset.name,
        "upstream": upstream,
        "downstream": downstream,
        "total_relationships": len(upstream) + len(downstream)
    }


from pydantic import BaseModel as PydanticBaseModel
from typing import Optional as OptType


class CreateRelationshipRequest(PydanticBaseModel):
    target_asset_id: UUID
    relationship_type: str  # parent_of, depends_on, connected_to, runs_on, backs_up_to
    description: OptType[str] = None
    criticality: OptType[float] = 3.0
    created_by: OptType[str] = None


@router.post("/{asset_id}/relationships")
async def create_asset_relationship(
    asset_id: UUID,
    request: CreateRelationshipRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new relationship between two assets.
    """
    from ..models.models import Asset, AssetRelationship
    import uuid as _uuid
    
    # Valid relationship types
    valid_types = ["parent_of", "child_of", "depends_on", "depended_by", "connected_to", "runs_on", "backs_up_to"]
    if request.relationship_type not in valid_types:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid relationship type. Must be one of: {', '.join(valid_types)}"
        )
    
    # Verify source asset exists
    source_asset = await asset_service.get_asset_by_id(db, asset_id)
    if not source_asset:
        raise HTTPException(status_code=404, detail="Source asset not found")
    
    # Verify target asset exists
    target_asset = await asset_service.get_asset_by_id(db, request.target_asset_id)
    if not target_asset:
        raise HTTPException(status_code=404, detail="Target asset not found")
    
    # Prevent self-referencing
    if asset_id == request.target_asset_id:
        raise HTTPException(status_code=400, detail="Cannot create relationship with self")
    
    # Check for existing relationship
    existing = await db.execute(
        select(AssetRelationship).filter(
            AssetRelationship.source_asset_id == asset_id,
            AssetRelationship.target_asset_id == request.target_asset_id,
            AssetRelationship.relationship_type == request.relationship_type
        )
    )
    if existing.scalars().first():
        raise HTTPException(status_code=400, detail="Relationship already exists")
    
    # Create relationship
    new_relationship = AssetRelationship(
        id=_uuid.uuid4(),
        source_asset_id=asset_id,
        target_asset_id=request.target_asset_id,
        relationship_type=request.relationship_type,
        description=request.description,
        criticality=request.criticality,
        created_by=request.created_by
    )
    
    db.add(new_relationship)
    await db.commit()
    await db.refresh(new_relationship)
    
    return {
        "status": "success",
        "relationship": {
            "id": str(new_relationship.id),
            "source_asset": {"id": str(asset_id), "name": source_asset.name},
            "target_asset": {"id": str(request.target_asset_id), "name": target_asset.name},
            "relationship_type": request.relationship_type,
            "criticality": request.criticality
        }
    }


@router.delete("/{asset_id}/relationships/{relationship_id}")
async def delete_asset_relationship(
    asset_id: UUID,
    relationship_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Delete a specific relationship.
    """
    from ..models.models import AssetRelationship
    
    # Find the relationship
    result = await db.execute(
        select(AssetRelationship).filter(
            AssetRelationship.id == relationship_id,
            (AssetRelationship.source_asset_id == asset_id) | (AssetRelationship.target_asset_id == asset_id)
        )
    )
    relationship = result.scalars().first()
    
    if not relationship:
        raise HTTPException(status_code=404, detail="Relationship not found")
    
    await db.delete(relationship)
    await db.commit()
    
    return {"status": "success", "message": f"Relationship {relationship_id} deleted"}
